--- drivers/net/wireless/rt2x00/rt2x00queue.c
+++ drivers/net/wireless/rt2x00/rt2x00queue.c
@@ -148,29 +148,55 @@
 	skb_trim(skb, frame_length);
 }
 
-/*
- * H/W needs L2 padding between the header and the paylod if header size
- * is not 4 bytes aligned.
- */
-void rt2x00queue_insert_l2pad(struct sk_buff *skb, unsigned int hdr_len)
+void rt2x00queue_insert_l2pad(struct sk_buff *skb, unsigned int header_length)
 {
-	unsigned int l2pad = (skb->len > hdr_len) ? L2PAD_SIZE(hdr_len) : 0;
+	unsigned int payload_length = skb->len - header_length;
+	unsigned int header_align = ALIGN_SIZE(skb, 0);
+	unsigned int payload_align = ALIGN_SIZE(skb, header_length);
+	unsigned int l2pad = payload_length ? L2PAD_SIZE(header_length) : 0;
+
+	/*
+	 * Adjust the header alignment if the payload needs to be moved more
+	 * than the header.
+	 */
+	if (payload_align > header_align)
+		header_align += 4;
 
-	if (!l2pad)
+	/* There is nothing to do if no alignment is needed */
+	if (!header_align)
 		return;
 
-	skb_push(skb, l2pad);
-	memmove(skb->data, skb->data + l2pad, hdr_len);
+	/* Reserve the amount of space needed in front of the frame */
+	skb_push(skb, header_align);
+
+	/*
+	 * Move the header.
+	 */
+	memmove(skb->data, skb->data + header_align, header_length);
+
+	/* Move the payload, if present and if required */
+	if (payload_length && payload_align)
+		memmove(skb->data + header_length + l2pad,
+			skb->data + header_length + l2pad + payload_align,
+			payload_length);
+
+	/* Trim the skb to the correct size */
+	skb_trim(skb, header_length + l2pad + payload_length);
 }
 
-void rt2x00queue_remove_l2pad(struct sk_buff *skb, unsigned int hdr_len)
+void rt2x00queue_remove_l2pad(struct sk_buff *skb, unsigned int header_length)
 {
-	unsigned int l2pad = (skb->len > hdr_len) ? L2PAD_SIZE(hdr_len) : 0;
+	/*
+	 * L2 padding is only present if the skb contains more than just the
+	 * IEEE 802.11 header.
+	 */
+	unsigned int l2pad = (skb->len > header_length) ?
+				L2PAD_SIZE(header_length) : 0;
 
 	if (!l2pad)
 		return;
 
-	memmove(skb->data + l2pad, skb->data, hdr_len);
+	memmove(skb->data + l2pad, skb->data, header_length);
 	skb_pull(skb, l2pad);
 }
 
@@ -181,7 +207,6 @@
 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
 	struct rt2x00_intf *intf = vif_to_intf(tx_info->control.vif);
-	u16 seqno;
 
 	if (!(tx_info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ))
 		return;
@@ -202,13 +227,15 @@
 	 * sequence counting per-frame, since those will override the
 	 * sequence counter given by mac80211.
 	 */
+	spin_lock(&intf->seqlock);
+
 	if (test_bit(ENTRY_TXD_FIRST_FRAGMENT, &txdesc->flags))
-		seqno = atomic_add_return(0x10, &intf->seqno);
-	else
-		seqno = atomic_read(&intf->seqno);
+		intf->seqno += 0x10;
+	hdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);
+	hdr->seq_ctrl |= cpu_to_le16(intf->seqno);
+
+	spin_unlock(&intf->seqlock);
 
-	hdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);
-	hdr->seq_ctrl |= cpu_to_le16(seqno);
 }
 
 static void rt2x00queue_create_tx_descriptor_plcp(struct rt2x00_dev *rt2x00dev,
@@ -830,8 +857,13 @@
 	spin_unlock_irqrestore(&queue->index_lock, irqflags);
 }
 
-void rt2x00queue_pause_queue_nocheck(struct data_queue *queue)
+void rt2x00queue_pause_queue(struct data_queue *queue)
 {
+	if (!test_bit(DEVICE_STATE_PRESENT, &queue->rt2x00dev->flags) ||
+	    !test_bit(QUEUE_STARTED, &queue->flags) ||
+	    test_and_set_bit(QUEUE_PAUSED, &queue->flags))
+		return;
+
 	switch (queue->qid) {
 	case QID_AC_VO:
 	case QID_AC_VI:
@@ -847,15 +879,6 @@
 		break;
 	}
 }
-void rt2x00queue_pause_queue(struct data_queue *queue)
-{
-	if (!test_bit(DEVICE_STATE_PRESENT, &queue->rt2x00dev->flags) ||
-	    !test_bit(QUEUE_STARTED, &queue->flags) ||
-	    test_and_set_bit(QUEUE_PAUSED, &queue->flags))
-		return;
-
-	rt2x00queue_pause_queue_nocheck(queue);
-}
 EXPORT_SYMBOL_GPL(rt2x00queue_pause_queue);
 
 void rt2x00queue_unpause_queue(struct data_queue *queue)
@@ -917,7 +940,7 @@
 		return;
 	}
 
-	rt2x00queue_pause_queue_nocheck(queue);
+	rt2x00queue_pause_queue(queue);
 
 	queue->rt2x00dev->ops->lib->stop_queue(queue);
 
