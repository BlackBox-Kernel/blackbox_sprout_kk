--- drivers/gpio/gpiolib.c
+++ drivers/gpio/gpiolib.c
@@ -60,7 +60,6 @@
 #define FLAG_ACTIVE_LOW	7	/* sysfs value has active low */
 #define FLAG_OPEN_DRAIN	8	/* Gpio is open drain type */
 #define FLAG_OPEN_SOURCE 9	/* Gpio is open source type */
-#define FLAG_SYSFS_DIR	10	/* show sysfs direction attribute */
 
 #define ID_SHIFT	16	/* add new flags before this one */
 
@@ -320,7 +319,7 @@
 	return status;
 }
 
-static DEVICE_ATTR(value, 0644,
+static const DEVICE_ATTR(value, 0644,
 		gpio_value_show, gpio_value_store);
 
 static irqreturn_t gpio_sysfs_irq(int irq, void *priv)
@@ -543,47 +542,17 @@
 	return status ? : size;
 }
 
-static DEVICE_ATTR(active_low, 0644,
+static const DEVICE_ATTR(active_low, 0644,
 		gpio_active_low_show, gpio_active_low_store);
 
-static umode_t gpio_is_visible(struct kobject *kobj, struct attribute *attr,
-			       int n)
-{
-	struct device *dev = container_of(kobj, struct device, kobj);
-	struct gpio_desc *desc = dev_get_drvdata(dev);
-	unsigned gpio = desc - gpio_desc;
-	umode_t mode = attr->mode;
-	bool show_direction = test_bit(FLAG_SYSFS_DIR, &desc->flags);
-
-	if (attr == &dev_attr_direction.attr) {
-		if (!show_direction)
-			mode = 0;
-	} else if (attr == &dev_attr_edge.attr) {
-		if (gpio_to_irq(gpio) < 0)
-			mode = 0;
-		if (!show_direction && test_bit(FLAG_IS_OUT, &desc->flags))
-			mode = 0;
-	}
-
-	return mode;
-}
-
-static struct attribute *gpio_attrs[] = {
-	&dev_attr_direction.attr,
-	&dev_attr_edge.attr,
+static const struct attribute *gpio_attrs[] = {
 	&dev_attr_value.attr,
 	&dev_attr_active_low.attr,
 	NULL,
 };
 
-static const struct attribute_group gpio_group = {
-	.attrs = gpio_attrs,
-	.is_visible = gpio_is_visible,
-};
-
-static const struct attribute_group *gpio_groups[] = {
-	&gpio_group,
-	NULL
+static const struct attribute_group gpio_attr_group = {
+	.attrs = (struct attribute **) gpio_attrs,
 };
 
 /*
@@ -620,13 +589,16 @@
 }
 static DEVICE_ATTR(ngpio, 0444, chip_ngpio_show, NULL);
 
-static struct attribute *gpiochip_attrs[] = {
+static const struct attribute *gpiochip_attrs[] = {
 	&dev_attr_base.attr,
 	&dev_attr_label.attr,
 	&dev_attr_ngpio.attr,
 	NULL,
 };
-ATTRIBUTE_GROUPS(gpiochip);
+
+static const struct attribute_group gpiochip_attr_group = {
+	.attrs = (struct attribute **) gpiochip_attrs,
+};
 
 /*
  * /sys/class/gpio/export ... write-only
@@ -651,11 +623,9 @@
 	 */
 
 	status = gpio_request(gpio, "sysfs");
-	if (status < 0) {
-		if (status == -EPROBE_DEFER)
-			status = -ENODEV;
+	if (status < 0)
 		goto done;
-	}
+
 	status = gpio_export(gpio, true);
 	if (status < 0)
 		gpio_free(gpio);
@@ -732,9 +702,8 @@
 {
 	unsigned long		flags;
 	struct gpio_desc	*desc;
-	int			status;
+	int			status = -EINVAL;
 	const char		*ioname = NULL;
-	struct device		*dev;
 
 	/* can't export until sysfs is available ... */
 	if (!gpio_class.p) {
@@ -742,50 +711,59 @@
 		return -ENOENT;
 	}
 
-	if (!gpio_is_valid(gpio)) {
-		pr_debug("%s: gpio %d is not valid\n", __func__, gpio);
-		return -EINVAL;
-	}
+	if (!gpio_is_valid(gpio))
+		goto done;
 
 	mutex_lock(&sysfs_lock);
 
 	spin_lock_irqsave(&gpio_lock, flags);
 	desc = &gpio_desc[gpio];
-	if (!test_bit(FLAG_REQUESTED, &desc->flags) ||
-	     test_bit(FLAG_EXPORT, &desc->flags)) {
-		spin_unlock_irqrestore(&gpio_lock, flags);
-		pr_debug("%s: gpio %d unavailable (requested=%d, exported=%d)\n",
-				__func__, gpio,
-				test_bit(FLAG_REQUESTED, &desc->flags),
-				test_bit(FLAG_EXPORT, &desc->flags));
-		return -EPERM;
+	if (test_bit(FLAG_REQUESTED, &desc->flags)
+			&& !test_bit(FLAG_EXPORT, &desc->flags)) {
+		status = 0;
+		if (!desc->chip->direction_input
+				|| !desc->chip->direction_output)
+			direction_may_change = false;
 	}
-
-	if (desc->chip->direction_input && desc->chip->direction_output &&
-			direction_may_change) {
-		set_bit(FLAG_SYSFS_DIR, &desc->flags);
-	}
-
 	spin_unlock_irqrestore(&gpio_lock, flags);
 
 	if (desc->chip->names && desc->chip->names[gpio - desc->chip->base])
 		ioname = desc->chip->names[gpio - desc->chip->base];
 
-	dev = device_create_with_groups(&gpio_class, desc->chip->dev,
-					MKDEV(0, 0), desc, gpio_groups,
-					ioname ? ioname : "gpio%u", gpio);
-	if (IS_ERR(dev)) {
-		status = PTR_ERR(dev);
-		goto fail_unlock;
+	if (status == 0) {
+		struct device	*dev;
+
+		dev = device_create(&gpio_class, desc->chip->dev, MKDEV(0, 0),
+				desc, ioname ? ioname : "gpio%u", gpio);
+		if (!IS_ERR(dev)) {
+			status = sysfs_create_group(&dev->kobj,
+						&gpio_attr_group);
+
+			if (!status && direction_may_change)
+				status = device_create_file(dev,
+						&dev_attr_direction);
+
+			if (!status && gpio_to_irq(gpio) >= 0
+					&& (direction_may_change
+						|| !test_bit(FLAG_IS_OUT,
+							&desc->flags)))
+				status = device_create_file(dev,
+						&dev_attr_edge);
+
+			if (status != 0)
+				device_unregister(dev);
+		} else
+			status = PTR_ERR(dev);
+		if (status == 0)
+			set_bit(FLAG_EXPORT, &desc->flags);
 	}
 
-	set_bit(FLAG_EXPORT, &desc->flags);
 	mutex_unlock(&sysfs_lock);
-	return 0;
 
-fail_unlock:
-	mutex_unlock(&sysfs_lock);
-	pr_debug("%s: gpio%d status %d\n", __func__, gpio, status);
+done:
+	if (status)
+		pr_debug("%s: gpio%d status %d\n", __func__, gpio, status);
+
 	return status;
 }
 EXPORT_SYMBOL_GPL(gpio_export);
@@ -825,7 +803,6 @@
 		if (tdev != NULL) {
 			status = sysfs_create_link(&dev->kobj, &tdev->kobj,
 						name);
-			put_device(tdev);
 		} else {
 			status = -ENODEV;
 		}
@@ -876,7 +853,7 @@
 	}
 
 	status = sysfs_set_active_low(desc, dev, value);
-	put_device(dev);
+
 unlock:
 	mutex_unlock(&sysfs_lock);
 
@@ -914,7 +891,6 @@
 		dev = class_find_device(&gpio_class, NULL, desc, match_export);
 		if (dev) {
 			gpio_setup_irq(desc, dev, 0);
-			clear_bit(FLAG_SYSFS_DIR, &desc->flags);
 			clear_bit(FLAG_EXPORT, &desc->flags);
 		} else
 			status = -ENODEV;
@@ -946,13 +922,13 @@
 
 	/* use chip->base for the ID; it's already known to be unique */
 	mutex_lock(&sysfs_lock);
-	dev = device_create_with_groups(&gpio_class, chip->dev, MKDEV(0, 0),
-					chip, gpiochip_groups,
-					"gpiochip%d", chip->base);
-	if (IS_ERR(dev))
+	dev = device_create(&gpio_class, chip->dev, MKDEV(0, 0), chip,
+				"gpiochip%d", chip->base);
+	if (!IS_ERR(dev)) {
+		status = sysfs_create_group(&dev->kobj,
+				&gpiochip_attr_group);
+	} else
 		status = PTR_ERR(dev);
-	else
-		status = 0;
 	chip->exported = (status == 0);
 	mutex_unlock(&sysfs_lock);
 
@@ -1103,18 +1079,19 @@
 				? (1 << FLAG_IS_OUT)
 				: 0;
 		}
+	}
 
-		of_gpiochip_add(chip);
-	}
+	of_gpiochip_add(chip);
 
 unlock:
 	spin_unlock_irqrestore(&gpio_lock, flags);
 
+	if (status)
+		goto fail;
+
 	status = gpiochip_export(chip);
-	if (status) {
-		of_gpiochip_remove(chip);
+	if (status)
 		goto fail;
-	}
 
 	pr_info("gpiochip_add: registered GPIOs %d to %d on device: %s\n",
 		chip->base, chip->base + chip->ngpio - 1,
@@ -1214,10 +1191,8 @@
 
 	spin_lock_irqsave(&gpio_lock, flags);
 
-	if (!gpio_is_valid(gpio)) {
-		status = -EINVAL;
+	if (!gpio_is_valid(gpio))
 		goto done;
-	}
 	desc = &gpio_desc[gpio];
 	chip = desc->chip;
 	if (chip == NULL)
