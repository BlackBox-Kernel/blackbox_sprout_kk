--- sound/i2c/other/ak4113.c
+++ sound/i2c/other/ak4113.c
@@ -56,7 +56,8 @@
 
 static void snd_ak4113_free(struct ak4113 *chip)
 {
-	atomic_inc(&chip->wq_processing);	/* don't schedule new work */
+	chip->init = 1;	/* don't schedule new work */
+	mb();
 	cancel_delayed_work_sync(&chip->work);
 	kfree(chip);
 }
@@ -88,7 +89,6 @@
 	chip->write = write;
 	chip->private_data = private_data;
 	INIT_DELAYED_WORK(&chip->work, ak4113_stats);
-	atomic_set(&chip->wq_processing, 0);
 
 	for (reg = 0; reg < AK4113_WRITABLE_REGS ; reg++)
 		chip->regmap[reg] = pgm[reg];
@@ -139,11 +139,13 @@
 
 void snd_ak4113_reinit(struct ak4113 *chip)
 {
-	if (atomic_inc_return(&chip->wq_processing) == 1)
-		cancel_delayed_work_sync(&chip->work);
+	chip->init = 1;
+	mb();
+	flush_delayed_work_sync(&chip->work);
 	ak4113_init_regs(chip);
 	/* bring up statistics / event queing */
-	if (atomic_dec_and_test(&chip->wq_processing))
+	chip->init = 0;
+	if (chip->kctls[0])
 		schedule_delayed_work(&chip->work, HZ / 10);
 }
 EXPORT_SYMBOL_GPL(snd_ak4113_reinit);
@@ -630,9 +632,8 @@
 {
 	struct ak4113 *chip = container_of(work, struct ak4113, work.work);
 
-	if (atomic_inc_return(&chip->wq_processing) == 1)
+	if (!chip->init)
 		snd_ak4113_check_rate_and_errors(chip, chip->check_flags);
 
-	if (atomic_dec_and_test(&chip->wq_processing))
-		schedule_delayed_work(&chip->work, HZ / 10);
+	schedule_delayed_work(&chip->work, HZ / 10);
 }
