--- sound/i2c/other/ak4114.c
+++ sound/i2c/other/ak4114.c
@@ -66,7 +66,8 @@
 
 static void snd_ak4114_free(struct ak4114 *chip)
 {
-	atomic_inc(&chip->wq_processing);	/* don't schedule new work */
+	chip->init = 1;	/* don't schedule new work */
+	mb();
 	cancel_delayed_work_sync(&chip->work);
 	kfree(chip);
 }
@@ -99,7 +100,6 @@
 	chip->write = write;
 	chip->private_data = private_data;
 	INIT_DELAYED_WORK(&chip->work, ak4114_stats);
-	atomic_set(&chip->wq_processing, 0);
 
 	for (reg = 0; reg < 7; reg++)
 		chip->regmap[reg] = pgm[reg];
@@ -152,11 +152,13 @@
 
 void snd_ak4114_reinit(struct ak4114 *chip)
 {
-	if (atomic_inc_return(&chip->wq_processing) == 1)
-		cancel_delayed_work_sync(&chip->work);
+	chip->init = 1;
+	mb();
+	flush_delayed_work_sync(&chip->work);
 	ak4114_init_regs(chip);
 	/* bring up statistics / event queing */
-	if (atomic_dec_and_test(&chip->wq_processing))
+	chip->init = 0;
+	if (chip->kctls[0])
 		schedule_delayed_work(&chip->work, HZ / 10);
 }
 
@@ -610,10 +612,10 @@
 {
 	struct ak4114 *chip = container_of(work, struct ak4114, work.work);
 
-	if (atomic_inc_return(&chip->wq_processing) == 1)
+	if (!chip->init)
 		snd_ak4114_check_rate_and_errors(chip, chip->check_flags);
-	if (atomic_dec_and_test(&chip->wq_processing))
-		schedule_delayed_work(&chip->work, HZ / 10);
+
+	schedule_delayed_work(&chip->work, HZ / 10);
 }
 
 EXPORT_SYMBOL(snd_ak4114_create);
