--- net/ipv6/ip6_fib.c
+++ net/ipv6/ip6_fib.c
@@ -633,29 +633,6 @@
 	return ln;
 }
 
-static void fib6_purge_rt(struct rt6_info *rt, struct fib6_node *fn,
-			  struct net *net)
-{
-	if (atomic_read(&rt->rt6i_ref) != 1) {
-		/* This route is used as dummy address holder in some split
-		 * nodes. It is not leaked, but it still holds other resources,
-		 * which must be released in time. So, scan ascendant nodes
-		 * and replace dummy references to this route with references
-		 * to still alive ones.
-		 */
-		while (fn) {
-			if (!(fn->fn_flags & RTN_RTINFO) && fn->leaf == rt) {
-				fn->leaf = fib6_find_prefix(net, fn);
-				atomic_inc(&fn->leaf->rt6i_ref);
-				rt6_release(rt);
-			}
-			fn = fn->parent;
-		}
-		/* No more references are possible at this point. */
-		BUG_ON(atomic_read(&rt->rt6i_ref) != 1);
-	}
-}
-
 /*
  *	Insert routing information in a node.
  */
@@ -746,12 +723,11 @@
 		rt->dst.rt6_next = iter->dst.rt6_next;
 		atomic_inc(&rt->rt6i_ref);
 		inet6_rt_notify(RTM_NEWROUTE, rt, info);
+		rt6_release(iter);
 		if (!(fn->fn_flags & RTN_RTINFO)) {
 			info->nl_net->ipv6.rt6_stats->fib_route_nodes++;
 			fn->fn_flags |= RTN_RTINFO;
 		}
-		fib6_purge_rt(iter, fn, info->nl_net);
-		rt6_release(iter);
 	}
 
 	return 0;
@@ -842,10 +818,6 @@
 					offsetof(struct rt6_info, rt6i_src),
 					allow_create, replace_required);
 
-			if (IS_ERR(sn)) {
-				err = PTR_ERR(sn);
-				sn = NULL;
-			}
 			if (!sn) {
 				/* If it is failed, discard just allocated
 				   root, and then (in st_failure) stale node
@@ -973,22 +945,14 @@
 
 			if (ipv6_prefix_equal(&key->addr, args->addr, key->plen)) {
 #ifdef CONFIG_IPV6_SUBTREES
-				if (fn->subtree) {
-					struct fib6_node *sfn;
-					sfn = fib6_lookup_1(fn->subtree,
-							    args + 1);
-					if (!sfn)
-						goto backtrack;
-					fn = sfn;
-				}
+				if (fn->subtree)
+					fn = fib6_lookup_1(fn->subtree, args + 1);
 #endif
-				if (fn->fn_flags & RTN_RTINFO)
+				if (!fn || fn->fn_flags & RTN_RTINFO)
 					return fn;
 			}
 		}
-#ifdef CONFIG_IPV6_SUBTREES
-backtrack:
-#endif
+
 		if (fn->fn_flags & RTN_ROOT)
 			break;
 
@@ -1253,7 +1217,24 @@
 		fn = fib6_repair_tree(net, fn);
 	}
 
-	fib6_purge_rt(rt, fn, net);
+	if (atomic_read(&rt->rt6i_ref) != 1) {
+		/* This route is used as dummy address holder in some split
+		 * nodes. It is not leaked, but it still holds other resources,
+		 * which must be released in time. So, scan ascendant nodes
+		 * and replace dummy references to this route with references
+		 * to still alive ones.
+		 */
+		while (fn) {
+			if (!(fn->fn_flags & RTN_RTINFO) && fn->leaf == rt) {
+				fn->leaf = fib6_find_prefix(net, fn);
+				atomic_inc(&fn->leaf->rt6i_ref);
+				rt6_release(rt);
+			}
+			fn = fn->parent;
+		}
+		/* No more references are possible at this point. */
+		BUG_ON(atomic_read(&rt->rt6i_ref) != 1);
+	}
 
 	inet6_rt_notify(RTM_DELROUTE, rt, info);
 	rt6_release(rt);
@@ -1579,7 +1560,7 @@
 				neigh_flags = neigh->flags;
 				neigh_release(neigh);
 			}
-			if (!(neigh_flags & NTF_ROUTER)) {
+			if (neigh_flags & NTF_ROUTER) {
 				RT6_TRACE("purging route %p via non-router but gateway\n",
 					  rt);
 				return -1;
